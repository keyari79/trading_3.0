//@version=6
// Macro_Patterns v1.2
// Created: 2025-11-21
// Updated: 2025-11-22 - Added CBRL/CBRS Pattern Stability Buffers
// UNIFIED PATTERN DETECTOR - Combines EPL/EPS and CBRL/CBRS patterns
// 
// NEW IN v1.2: CBRL/CBRS Invalidation Buffers (Active During RETEST Phase)
//   - Distance Buffer: Measures proximity to retest failure level (ATR units)
//   - Time Buffer: Estimates bars until retest window expires or ADX drops below 20
//   - Risk Classification: STRONG/MODERATE/WEAK/FRAGILE ratings
//   - Critical Price Level: Exact price where retest fails
//
// NEW IN v1.1: EPL/EPS Pattern Stability Buffers
//   - Distance Buffer: Minimum of (200 EMA, Zone boundary, 100 EMA violation) in ATR units
//   - Time Buffer: ADX time-to-threshold in bars (hours on 1H timeframe)
//   - Risk Classification: STRONG/MODERATE/WEAK/FRAGILE ratings
//   - Critical Price Level: Exact price where pattern invalidates
//
// This indicator merges the functionality of:
//   - Macro_EP v3.0 (EPL/EPS pattern detection)
//   - Macro_CBR v1.0 (CBRL/CBRS pattern detection)
//
// WHY UNIFIED:
//   - EPL/EPS and CBRL/CBRS patterns are mutually exclusive (can't both be active)
//   - 80% code overlap (both require same core calculations for quality scoring)
//   - Better user experience: load once, see all pattern types
//   - No visual duplication (single histogram, single table)
//
// PATTERN SUPPORT:
//   - EPL: EMA Pullback Long (bullish trend continuation)
//   - EPS: EMA Pullback Short (bearish trend continuation)
//   - CBRL: Consolidation Breakout Retest Long (bullish breakout)
//   - CBRS: Consolidation Breakout Retest Short (bearish breakout)
//
// Purpose: Comprehensive macro pattern detection for all FOCUS patterns on 1H timeframe
// Use with: Micro_EP v2.0 for EPL/EPS entry execution, Micro_CBR v1.0 for CBRL/CBRS entry execution

indicator("Macro_Patterns v1.2", overlay=false)

// ============================================
// INPUT PARAMETERS - SHARED CORE
// ============================================

// EMA Settings
ema20_length = input.int(20, "EMA 20", group="Moving Averages")
ema50_length = input.int(50, "EMA 50", group="Moving Averages")
ema100_length = input.int(100, "EMA 100", group="Moving Averages")
ema200_length = input.int(200, "EMA 200", group="Moving Averages")

// EMA Display Toggles
show_ema20 = input.bool(false, "Show EMA 20", group="Moving Averages", tooltip="EMA 20 = Keltner Basis (redundant)")
show_ema50 = input.bool(true, "Show EMA 50", group="Moving Averages", tooltip="Mid-term trend reference")
show_ema100 = input.bool(true, "Show EMA 100", group="Moving Averages", tooltip="Stop loss reference")
show_ema200 = input.bool(true, "Show EMA 200", group="Moving Averages", tooltip="Macro trend reference")

// ADX Settings
adx_length = input.int(14, "ADX Length", group="Trend Strength")
adx_threshold = input.int(25, "ADX Trending Threshold", group="Trend Strength")

// ATR Settings
atr_length = input.int(14, "ATR Length", group="Volatility Measurement")
atr_fast = input.int(10, "ATR Fast (for ratio)", group="Volatility Measurement")
atr_slow = input.int(20, "ATR Slow (for ratio)", group="Volatility Measurement")

// Keltner Settings
keltner_length = input.int(20, "Keltner EMA Length", group="Keltner Channels")
keltner_mult = input.float(2.0, "Keltner ATR Multiplier", group="Keltner Channels")
keltner_atr_length = input.int(10, "Keltner ATR Length", group="Keltner Channels")
show_keltner = input.bool(true, "Show Keltner Fill", group="Keltner Channels")

// Trend Consistency Settings
consistency_lookback = input.int(20, "Consistency Lookback Bars", group="Trend Duration")
duration_display_mode = input.string("Color-Coded Quality", "Display Mode", options=["Basic + Labels", "With Entry Quality", "Color-Coded Quality"], group="Trend Duration", tooltip="Basic: Shows classifications only\nEntry Quality: Adds explicit quality signal\nColor-Coded: Uses cell color to show quality (DEFAULT)")

// Volatility Regime Settings
vol_expansion_threshold = input.float(1.5, "Expansion Threshold", group="Volatility Regime")
vol_elevated_threshold = input.float(1.2, "Elevated Threshold", group="Volatility Regime")
vol_compression_threshold = input.float(0.8, "Compression Threshold", group="Volatility Regime")

// Wave Detection Settings
wave_detection_method = input.string("Smoothed + Lower Threshold", "Wave Start Detection", options=["Smoothed + Lower Threshold", "Compression Duration + First Rise"], group="Wave Detection Method", tooltip="Method 1 (DEFAULT): Smoothed percentile with lower threshold\nMethod 2: Sustained compression + first rise")
wave_percentile_lookback = input.int(50, "Wave Percentile Lookback", minval=20, maxval=200, group="Wave Detection Settings")
wave_peak_threshold = input.float(90, "Wave Peak Threshold", group="Wave Detection Settings")
wave_smoothing_period = input.int(3, "Smoothing Period (Method 1)", minval=2, maxval=10, group="Wave Detection Settings")
wave_compression_threshold = input.float(10, "Compression Threshold (Method 1)", group="Wave Detection Settings")
wave_trigger_threshold = input.float(15, "Trigger Threshold (Method 1)", group="Wave Detection Settings")
wave_compression_duration = input.int(3, "Min Compression Bars (Method 2)", minval=1, maxval=10, group="Wave Detection Settings")
wave_compression_level = input.float(15, "Compression Level (Method 2)", group="Wave Detection Settings")

// ATR Extreme Detection Settings
atr_extreme_high = input.float(1.2, "ATR Extreme High", group="ATR Extreme Detection")
atr_extreme_low = input.float(0.8, "ATR Extreme Low", group="ATR Extreme Detection")

// ============================================
// INPUT PARAMETERS - EPL/EPS PATTERNS
// ============================================

enable_epl_eps = input.bool(true, "Enable EPL/EPS Detection", group="EPL/EPS Patterns", tooltip="Enable EMA Pullback pattern detection")
show_ema_zone_highlight = input.bool(true, "Highlight 50-100 EMA Zone", group="EPL/EPS Patterns", tooltip="Fill zone when EPL/EPS pattern active")

// ============================================
// INPUT PARAMETERS - CBRL/CBRS PATTERNS
// ============================================

enable_cbrl_cbrs = input.bool(true, "Enable CBRL/CBRS Detection", group="CBRL/CBRS Patterns", tooltip="Enable Consolidation Breakout Retest pattern detection")
consolidation_min_bars = input.int(10, "Min Consolidation Bars", group="CBRL/CBRS Patterns")
consolidation_max_bars = input.int(30, "Max Consolidation Bars", group="CBRL/CBRS Patterns")
consolidation_min_atr = input.float(1.5, "Min Range (ATR)", group="CBRL/CBRS Patterns")
consolidation_max_atr = input.float(4.0, "Max Range (ATR)", group="CBRL/CBRS Patterns")
breakout_buffer = input.float(0.1, "Breakout Buffer (ATR)", group="CBRL/CBRS Patterns", tooltip="Buffer for breakout confirmation")
retest_window = input.int(5, "Retest Window (bars)", group="CBRL/CBRS Patterns", tooltip="Maximum bars between breakout and retest")
retest_tolerance = input.float(0.3, "Retest Tolerance (ATR)", group="CBRL/CBRS Patterns", tooltip="Maximum distance from breakout level for valid retest")
show_consolidation_boxes = input.bool(true, "Show Consolidation Boxes", group="CBRL/CBRS Patterns")
max_stored_consolidations = input.int(3, "Max Stored Consolidations", group="CBRL/CBRS Patterns", tooltip="Number of recent consolidations to track")

// ============================================
// INPUT PARAMETERS - BUFFER SYSTEM
// ============================================

enable_buffers = input.bool(true, "Enable Pattern Buffers", group="Buffer System v1.2", tooltip="Show distance and time buffers for patterns")
show_critical_level = input.bool(true, "Show Critical Level Row", group="Buffer System v1.2", tooltip="Display Row 8 with critical price level")
show_critical_line = input.bool(false, "Show Critical Level Line", group="Buffer System v1.2", tooltip="Draw horizontal line at critical level on chart")

// Buffer Thresholds
buffer_distance_strong = input.float(5.0, "Distance Strong (ATR)", group="Buffer Thresholds")
buffer_distance_moderate = input.float(3.0, "Distance Moderate (ATR)", group="Buffer Thresholds")
buffer_distance_weak = input.float(2.0, "Distance Weak (ATR)", group="Buffer Thresholds")
buffer_time_strong = input.float(20.0, "Time Strong (bars)", group="Buffer Thresholds")
buffer_time_moderate = input.float(10.0, "Time Moderate (bars)", group="Buffer Thresholds")
buffer_time_weak = input.float(5.0, "Time Weak (bars)", group="Buffer Thresholds")

// ============================================
// INPUT PARAMETERS - PATTERN DISPLAY
// ============================================

show_pattern_label = input.bool(true, "Show Pattern Labels", group="Pattern Display", tooltip="Display pattern labels on chart when pattern active")

// Table Settings
table_position = input.string("top_right", "Table Position", options=["top_left", "top_center", "top_right", "middle_left", "middle_center", "middle_right", "bottom_left", "bottom_center", "bottom_right"], group="Display")
table_text_size = input.string("small", "Table Text Size", options=["auto", "small", "normal"], group="Display")

// ============================================
// SHARED CORE CALCULATIONS
// ============================================

// EMAs
ema20 = ta.ema(close, ema20_length)
ema50 = ta.ema(close, ema50_length)
ema100 = ta.ema(close, ema100_length)
ema200 = ta.ema(close, ema200_length)

// ATR for distance measurement
atr = ta.atr(atr_length)

// ATR Ratio for volatility regime detection
atr_fast_value = ta.atr(atr_fast)
atr_slow_value = ta.atr(atr_slow)
atr_ratio = atr_fast_value / atr_slow_value

// Volatility Regime Classification - 4 states
vol_regime = atr_ratio >= vol_expansion_threshold ? "EXPANSION" : atr_ratio >= vol_elevated_threshold ? "ELEVATED" : atr_ratio <= vol_compression_threshold ? "COMPRESSION" : "NORMAL"

// ATR Extreme Detection
atr_is_extreme = atr_ratio > atr_extreme_high or atr_ratio < atr_extreme_low
atr_extreme_type = atr_ratio > atr_extreme_high ? "HIGH" : atr_ratio < atr_extreme_low ? "LOW" : "NORMAL"

// Volatility Wave Detection - ATR Percentile Calculation
var float wave_percentile_rank = na
if bar_index >= wave_percentile_lookback
    float count_below = 0.0
    for i = 1 to wave_percentile_lookback
        if atr_ratio[i] < atr_ratio
            count_below += 1.0
    wave_percentile_rank := (count_below / wave_percentile_lookback) * 100
else
    wave_percentile_rank := na

// DUAL WAVE START DETECTION METHODS
percentile_smooth = ta.ema(wave_percentile_rank, wave_smoothing_period)

var bool method1_was_compressed = false
var bool method1_wave_start = false

if not na(percentile_smooth)
    if percentile_smooth < wave_compression_threshold
        method1_was_compressed := true
    if method1_was_compressed and percentile_smooth > wave_trigger_threshold
        method1_wave_start := true
        method1_was_compressed := false
    else
        method1_wave_start := false

var int compression_bar_count = 0
var bool method2_wave_start = false

if not na(wave_percentile_rank)
    if wave_percentile_rank < wave_compression_level
        compression_bar_count += 1
    else
        compression_bar_count := 0
    if compression_bar_count[1] >= wave_compression_duration and wave_percentile_rank > wave_percentile_rank[1]
        method2_wave_start := true
    else
        method2_wave_start := false

wave_start_signal = wave_detection_method == "Smoothed + Lower Threshold" ? method1_wave_start : method2_wave_start

// WAVE STAGE LOGIC
var string wave_stage = "DORMANT"
var bool was_above_peak = false

if not na(wave_percentile_rank)
    if wave_start_signal
        wave_stage := "STARTING"
        was_above_peak := false
    if wave_percentile_rank > wave_peak_threshold
        wave_stage := "PEAKING"
        was_above_peak := true
    if was_above_peak and wave_percentile_rank < wave_compression_level
        wave_stage := "ENDING"
        was_above_peak := false
    if wave_stage == "ENDING" and wave_percentile_rank < wave_compression_threshold
        wave_stage := "DORMANT"

wave_peak_signal = wave_stage == "PEAKING" and wave_stage[1] != "PEAKING"

// ADX and Directional Indicators
[diPlus, diMinus, adx] = ta.dmi(adx_length, adx_length)

// DI Gap (Directional Bias Strength)
di_gap = diPlus - diMinus

// ADX-Weighted DI Gap (combines direction and strength)
adx_weighted_di_gap = di_gap * (adx / adx_threshold)

// Keltner Channels
keltner_basis = ta.ema(close, keltner_length)
keltner_range = ta.atr(keltner_atr_length) * keltner_mult
keltner_upper = keltner_basis + keltner_range
keltner_lower = keltner_basis - keltner_range

// Keltner Position (0-100%)
keltner_position = ((close - keltner_lower) / (keltner_upper - keltner_lower)) * 100

// Keltner Position Zone Classification
var string keltner_zone = ""
if keltner_position >= 80
    keltner_zone := "UPPER"
else if keltner_position >= 60
    keltner_zone := "MID-HIGH"
else if keltner_position >= 40
    keltner_zone := "MIDDLE"
else if keltner_position >= 20
    keltner_zone := "MID-LOW"
else
    keltner_zone := "LOWER"

var bool is_extreme = keltner_position > 100 or keltner_position < 0

// Macro Trend (based on 200 EMA)
macro_trend = close > ema200 ? "BULL" : "BEAR"

// Trend Duration - Bars above/below 200 EMA
var int trend_bars = 0
current_above = close > ema200

if current_above != current_above[1]
    trend_bars := 1
else
    trend_bars += 1

// Trend Consistency - % of bars CONFIRMING current trend
var float consistency_sum = 0.0
for i = 0 to consistency_lookback - 1
    if current_above
        if close[i] > ema200[i]
            consistency_sum += 1.0
    else
        if close[i] < ema200[i]
            consistency_sum += 1.0

trend_consistency = (consistency_sum / consistency_lookback) * 100
consistency_sum := 0.0

// Duration and Consistency Classifications
var string duration_class = ""
if trend_bars < 10
    duration_class := "FRESH"
else if trend_bars < 50
    duration_class := "DEVELOPING"
else if trend_bars < 100
    duration_class := "MATURE"
else
    duration_class := "EXTENDED"

var string consistency_class = ""
if trend_consistency >= 80
    consistency_class := "STRONG"
else if trend_consistency >= 60
    consistency_class := "MODERATE"
else if trend_consistency >= 50
    consistency_class := "WEAK"
else
    consistency_class := "VERY WEAK"

// Entry Quality Assessment
var string entry_quality = ""
var color entry_quality_color = color.gray

if trend_bars >= 100 or trend_consistency < 50
    entry_quality := "❌ AVOID"
    entry_quality_color := color.new(color.red, 30)
else if (trend_bars < 10 and trend_consistency < 70) or (trend_consistency >= 50 and trend_consistency < 60)
    entry_quality := "⚠️ MARGINAL"
    entry_quality_color := color.new(color.yellow, 50)
else
    entry_quality := "✅ PRIME"
    entry_quality_color := color.new(color.green, 50)

// ============================================
// EPL/EPS PATTERN DETECTION MODULE
// ============================================

var string epl_eps_pattern = "NONE"
var int epl_eps_quality = 0
var bool epl_eps_valid = false

if enable_epl_eps
    // 50-100 EMA Zone Detection
    in_ema_zone = close >= math.min(ema50, ema100) and close <= math.max(ema50, ema100)
    price_above_zone = close > math.max(ema50, ema100)
    price_below_zone = close < math.min(ema50, ema100)
    
    // Track 100 EMA violations during pullback
    var bool pullback_active = false
    var bool ema100_violated = false
    
    if macro_trend == "BULL"
        if price_above_zone and not pullback_active
            pullback_active := true
            ema100_violated := false
        if pullback_active and close < ema100
            ema100_violated := true
        if not in_ema_zone and not price_above_zone
            pullback_active := false
    
    if macro_trend == "BEAR"
        if price_below_zone and not pullback_active
            pullback_active := true
            ema100_violated := false
        if pullback_active and close > ema100
            ema100_violated := true
        if not in_ema_zone and not price_below_zone
            pullback_active := false
    
    // EPL Pattern Detection (all core requirements)
    epl_core_met = macro_trend == "BULL" and in_ema_zone and not ema100_violated and keltner_position > 50
    
    // EPS Pattern Detection (all core requirements)
    eps_core_met = macro_trend == "BEAR" and in_ema_zone and not ema100_violated and keltner_position < 50
    
    // Determine active EPL/EPS pattern
    if epl_core_met
        epl_eps_pattern := "EPL"
    else if eps_core_met
        epl_eps_pattern := "EPS"
    else
        epl_eps_pattern := "NONE"
    
    // Pattern Quality Scoring (0-4 points from Pattern Library v1.9)
    if epl_eps_pattern != "NONE"
        epl_eps_quality := 0
        if wave_stage == "STARTING" or wave_stage == "NORMAL"
            epl_eps_quality += 1
        if vol_regime == "NORMAL" or vol_regime == "COMPRESSION"
            epl_eps_quality += 1
        if adx >= 15 and adx <= 40
            epl_eps_quality += 1
        if trend_bars < 80
            epl_eps_quality += 1
    else
        epl_eps_quality := 0
    
    // Pattern validity (minimum 2/4 required)
    epl_eps_valid := epl_eps_quality >= 2
else
    epl_eps_pattern := "NONE"
    epl_eps_quality := 0
    epl_eps_valid := false

// ============================================
// EPL/EPS BUFFER SYSTEM CALCULATIONS (v1.1)
// ============================================

// Storage variables for EPL/EPS buffer display persistence
var float display_distance_buffer = na
var float display_time_buffer = na
var string display_overall_rating = na
var float display_critical_level = na
var string display_break_source = na

// Helper function for worse rating comparison
get_worse_rating(string rating1, string rating2) =>
    int risk1 = rating1 == "STRONG" ? 1 : rating1 == "MODERATE" ? 2 : rating1 == "WEAK" ? 3 : 4
    int risk2 = rating2 == "STRONG" ? 1 : rating2 == "MODERATE" ? 2 : rating2 == "WEAK" ? 3 : 4
    int worse_risk = math.max(risk1, risk2)
    worse_risk == 4 ? "FRAGILE" : worse_risk == 3 ? "WEAK" : worse_risk == 2 ? "MODERATE" : "STRONG"

// Calculate EPL/EPS buffers at confirmed close
if barstate.isconfirmed and enable_buffers and epl_eps_pattern != "NONE" and epl_eps_valid
    
    // === DISTANCE BUFFER CALCULATION ===
    float buffer_200ema = na
    float buffer_zone = na
    float buffer_100ema = na
    float distance_buffer = na
    string break_source = ""
    float critical_level = na
    
    if epl_eps_pattern == "EPL"
        // EPL: Bullish pattern - measure downside distances
        buffer_200ema := (close - ema200) / atr
        buffer_zone := (close - ema100) / atr  // Lower boundary for EPL
        buffer_100ema := (close - ema100) / atr
        
        // Find weakest (minimum)
        distance_buffer := math.min(buffer_200ema, math.min(buffer_zone, buffer_100ema))
        
        // Identify which is weakest
        if distance_buffer == buffer_200ema
            break_source := "Macro Trend"
            critical_level := ema200
        else
            break_source := "Zone Exit"
            critical_level := ema100
    
    else if epl_eps_pattern == "EPS"
        // EPS: Bearish pattern - measure upside distances
        buffer_200ema := (ema200 - close) / atr
        buffer_zone := (ema50 - close) / atr  // Upper boundary for EPS
        buffer_100ema := (ema100 - close) / atr
        
        // Find weakest (minimum)
        distance_buffer := math.min(buffer_200ema, math.min(buffer_zone, buffer_100ema))
        
        // Identify which is weakest
        if distance_buffer == buffer_200ema
            break_source := "Macro Trend"
            critical_level := ema200
        else if distance_buffer == buffer_zone
            break_source := "Zone Exit"
            critical_level := ema50
        else
            break_source := "100 EMA"
            critical_level := ema100
    
    // === ADX TIME BUFFER CALCULATION ===
    float adx_velocity = ta.change(adx, 1)
    float adx_velocity_smooth = ta.sma(adx_velocity, 3)
    
    float lower_buffer = 999.0
    float upper_buffer = 999.0
    
    // Lower threshold (ADX dropping below 15)
    if adx_velocity_smooth < 0 and adx > 15.0
        lower_buffer := (adx - 15.0) / math.abs(adx_velocity_smooth)
    else if adx <= 15.0
        lower_buffer := 0.0
    
    // Upper threshold (ADX rising above 40)
    if adx_velocity_smooth > 0 and adx < 40.0
        upper_buffer := (40.0 - adx) / adx_velocity_smooth
    else if adx >= 40.0
        upper_buffer := 0.0
    
    // Take minimum (weakest side)
    float time_buffer = math.min(lower_buffer, upper_buffer)
    
    // Handle edge case: velocity near zero
    if math.abs(adx_velocity_smooth) < 0.01
        time_buffer := 999.0
    
    // === RISK CLASSIFICATION ===
    string distance_rating = distance_buffer > buffer_distance_strong ? "STRONG" : distance_buffer > buffer_distance_moderate ? "MODERATE" : distance_buffer > buffer_distance_weak ? "WEAK" : "FRAGILE"
    string time_rating = time_buffer > buffer_time_strong ? "STRONG" : time_buffer > buffer_time_moderate ? "MODERATE" : time_buffer > buffer_time_weak ? "WEAK" : "FRAGILE"
    string overall_rating = get_worse_rating(distance_rating, time_rating)
    
    // Store for display
    display_distance_buffer := distance_buffer
    display_time_buffer := time_buffer
    display_overall_rating := overall_rating
    display_critical_level := critical_level
    display_break_source := break_source

else if not epl_eps_valid or epl_eps_pattern == "NONE"
    // Clear buffers when pattern not valid
    display_distance_buffer := na
    display_time_buffer := na
    display_overall_rating := na
    display_critical_level := na
    display_break_source := na

// ============================================
// CBRL/CBRS PATTERN DETECTION MODULE
// ============================================

var string cbrl_cbrs_pattern = "NONE"
var int cbrl_cbrs_quality = 0
var bool cbrl_cbrs_valid = false
var string pattern_state = "SCANNING"

// Consolidation tracking arrays
var array<float> consol_highs = array.new<float>(0)
var array<float> consol_lows = array.new<float>(0)
var array<int> consol_start_bars = array.new<int>(0)
var array<int> consol_bar_counts = array.new<int>(0)

// Active consolidation variables
var bool in_consolidation = false
var float current_consol_high = na
var float current_consol_low = na
var int consol_start_bar = na
var int consol_bars = 0

// Breakout tracking
var bool breakout_occurred = false
var int breakout_direction = 0
var float breakout_level = na
var int breakout_bar = na
var int bars_since_breakout = 0

// Retest tracking
var bool retest_occurred = false
var bool retest_valid = false
var bool retest_bounce_confirmed = false

if enable_cbrl_cbrs
    // MODULE 1: CONSOLIDATION DETECTION
    if not in_consolidation and not breakout_occurred
        pattern_state := "SCANNING"
        bool consolidation_forming = true
        float range_high = high
        float range_low = low
        for i = 1 to consolidation_max_bars
            if i <= bar_index
                range_high := math.max(range_high, high[i])
                range_low := math.min(range_low, low[i])
        range_height = range_high - range_low
        range_height_atr = range_height / atr
        if consol_bars >= consolidation_min_bars and consol_bars <= consolidation_max_bars
            if range_height_atr >= consolidation_min_atr and range_height_atr <= consolidation_max_atr
                float range_mid = (range_high + range_low) / 2
                bool within_keltner = range_mid >= keltner_lower and range_mid <= keltner_upper
                if within_keltner
                    if not in_consolidation
                        in_consolidation := true
                        current_consol_high := range_high
                        current_consol_low := range_low
                        consol_start_bar := bar_index - consol_bars
                        pattern_state := "CONSOLIDATING"
        if in_consolidation
            current_consol_high := math.max(current_consol_high, high)
            current_consol_low := math.min(current_consol_low, low)
            consol_bars += 1
            if consol_bars > consolidation_max_bars
                if array.size(consol_highs) >= max_stored_consolidations
                    array.shift(consol_highs)
                    array.shift(consol_lows)
                    array.shift(consol_start_bars)
                    array.shift(consol_bar_counts)
                array.push(consol_highs, current_consol_high)
                array.push(consol_lows, current_consol_low)
                array.push(consol_start_bars, consol_start_bar)
                array.push(consol_bar_counts, consol_bars)
                in_consolidation := false
                consol_bars := 0
        else
            consol_bars += 1
            if consol_bars > consolidation_max_bars
                consol_bars := 0
    
    // MODULE 2: BREAKOUT DETECTION
    if in_consolidation and not breakout_occurred
        float breakout_buffer_distance = atr * breakout_buffer
        if close > current_consol_high + breakout_buffer_distance
            breakout_occurred := true
            breakout_direction := 1
            breakout_level := current_consol_high
            breakout_bar := bar_index
            bars_since_breakout := 0
            pattern_state := "BREAKOUT"
            if array.size(consol_highs) >= max_stored_consolidations
                array.shift(consol_highs)
                array.shift(consol_lows)
                array.shift(consol_start_bars)
                array.shift(consol_bar_counts)
            array.push(consol_highs, current_consol_high)
            array.push(consol_lows, current_consol_low)
            array.push(consol_start_bars, consol_start_bar)
            array.push(consol_bar_counts, consol_bars)
            in_consolidation := false
        else if close < current_consol_low - breakout_buffer_distance
            breakout_occurred := true
            breakout_direction := -1
            breakout_level := current_consol_low
            breakout_bar := bar_index
            bars_since_breakout := 0
            pattern_state := "BREAKOUT"
            if array.size(consol_highs) >= max_stored_consolidations
                array.shift(consol_highs)
                array.shift(consol_lows)
                array.shift(consol_start_bars)
                array.shift(consol_bar_counts)
            array.push(consol_highs, current_consol_high)
            array.push(consol_lows, current_consol_low)
            array.push(consol_start_bars, consol_start_bar)
            array.push(consol_bar_counts, consol_bars)
            in_consolidation := false
    
    // MODULE 3: RETEST VALIDATION
    if breakout_occurred and not retest_occurred
        bars_since_breakout += 1
        if bars_since_breakout <= retest_window
            float retest_tolerance_distance = atr * retest_tolerance
            float distance_to_level = math.abs(close - breakout_level)
            if distance_to_level <= retest_tolerance_distance
                retest_occurred := true
                pattern_state := "RETEST"
                if breakout_direction == 1
                    if close > breakout_level and low <= breakout_level + retest_tolerance_distance
                        retest_bounce_confirmed := true
                        retest_valid := true
                else if breakout_direction == -1
                    if close < breakout_level and high >= breakout_level - retest_tolerance_distance
                        retest_bounce_confirmed := true
                        retest_valid := true
        else
            breakout_occurred := false
            breakout_direction := 0
            bars_since_breakout := 0
            pattern_state := "SCANNING"
    
    // MODULE 4: PATTERN STATE MACHINE & QUALITY SCORING
    if retest_valid and retest_bounce_confirmed
        pattern_state := "COMPLETE"
        if breakout_direction == 1 and macro_trend == "BULL"
            cbrl_cbrs_pattern := "CBRL"
        else if breakout_direction == -1 and macro_trend == "BEAR"
            cbrl_cbrs_pattern := "CBRS"
        else
            cbrl_cbrs_pattern := "NONE"
        if cbrl_cbrs_pattern != "NONE"
            cbrl_cbrs_quality := 0
            if wave_stage == "NORMAL" or wave_stage == "STARTING"
                cbrl_cbrs_quality += 1
            if vol_regime == "NORMAL" or vol_regime == "COMPRESSION"
                cbrl_cbrs_quality += 1
            if (cbrl_cbrs_pattern == "CBRL" and keltner_position > 50) or (cbrl_cbrs_pattern == "CBRS" and keltner_position < 50)
                cbrl_cbrs_quality += 1
            if not na(breakout_level) and array.size(consol_highs) > 0 and array.size(consol_lows) > 0
                float consol_mid = (array.get(consol_highs, array.size(consol_highs) - 1) + array.get(consol_lows, array.size(consol_lows) - 1)) / 2
                bool near_50ema = math.abs(consol_mid - ema50) <= atr
                bool between_emas = consol_mid >= math.min(ema50, ema100) and consol_mid <= math.max(ema50, ema100)
                if near_50ema or between_emas
                    cbrl_cbrs_quality += 1
            cbrl_cbrs_valid := cbrl_cbrs_quality >= 2 and adx > 20
        else
            cbrl_cbrs_quality := 0
            cbrl_cbrs_valid := false
    else
        cbrl_cbrs_pattern := "NONE"
        cbrl_cbrs_quality := 0
        cbrl_cbrs_valid := false
    if retest_occurred and not retest_valid
        breakout_occurred := false
        retest_occurred := false
        breakout_direction := 0
        bars_since_breakout := 0
        pattern_state := "SCANNING"
else
    cbrl_cbrs_pattern := "NONE"
    cbrl_cbrs_quality := 0
    cbrl_cbrs_valid := false
    pattern_state := "SCANNING"

// ============================================
// CBRL/CBRS BUFFER SYSTEM CALCULATIONS (v1.2)
// ============================================

// Storage variables for CBR buffer display persistence
var float display_distance_buffer_cbr = na
var float display_time_buffer_cbr = na
var string display_overall_rating_cbr = na
var float display_critical_level_cbr = na
var string display_break_source_cbr = ""

// Determine if pattern is in RETEST phase
bool cbrl_retest_active = enable_cbrl_cbrs and cbrl_cbrs_pattern == "CBRL" and pattern_state == "RETEST"
bool cbrs_retest_active = enable_cbrl_cbrs and cbrl_cbrs_pattern == "CBRS" and pattern_state == "RETEST"

// Calculate buffers at confirmed close during RETEST phase only
if barstate.isconfirmed and enable_buffers and (cbrl_retest_active or cbrs_retest_active)
    
    // === DISTANCE BUFFER CALCULATION ===
    float buffer_failure = na
    float buffer_200ema = na
    float distance_buffer = na
    string break_source = ""
    float critical_level = na
    float failure_level = na
    
    if cbrl_retest_active
        // CBRL: Bullish breakout retest - measure downside distances
        failure_level := breakout_level - (retest_tolerance * atr)
        buffer_failure := (close - failure_level) / atr
        buffer_200ema := (close - ema200) / atr
        
        distance_buffer := math.min(buffer_failure, buffer_200ema)
        
        if distance_buffer == buffer_failure
            break_source := "Retest Failure"
            critical_level := failure_level
        else
            break_source := "Macro Trend"
            critical_level := ema200
    
    else if cbrs_retest_active
        // CBRS: Bearish breakout retest - measure upside distances
        failure_level := breakout_level + (retest_tolerance * atr)
        buffer_failure := (failure_level - close) / atr
        buffer_200ema := (ema200 - close) / atr
        
        distance_buffer := math.min(buffer_failure, buffer_200ema)
        
        if distance_buffer == buffer_failure
            break_source := "Retest Failure"
            critical_level := failure_level
        else
            break_source := "Macro Trend"
            critical_level := ema200
    
    // === TIME BUFFER CALCULATION ===
    float buffer_window = retest_window - bars_since_breakout
    
    float adx_velocity = ta.change(adx, 1)
    float adx_velocity_smooth = ta.sma(adx_velocity, 3)
    
    float buffer_adx = 999.0
    if adx_velocity_smooth < 0 and adx > 20.0
        buffer_adx := (adx - 20.0) / math.abs(adx_velocity_smooth)
    else if adx <= 20.0
        buffer_adx := 0.0
    
    if math.abs(adx_velocity_smooth) < 0.01
        buffer_adx := 999.0
    
    float time_buffer = math.min(buffer_window, buffer_adx)
    
    // === RISK CLASSIFICATION ===
    string distance_rating = distance_buffer > buffer_distance_strong ? "STRONG" : distance_buffer > buffer_distance_moderate ? "MODERATE" : distance_buffer > buffer_distance_weak ? "WEAK" : "FRAGILE"
    string time_rating = time_buffer > buffer_time_strong ? "STRONG" : time_buffer > buffer_time_moderate ? "MODERATE" : time_buffer > buffer_time_weak ? "WEAK" : "FRAGILE"
    string overall_rating = get_worse_rating(distance_rating, time_rating)
    
    // Store for display
    display_distance_buffer_cbr := distance_buffer
    display_time_buffer_cbr := time_buffer
    display_overall_rating_cbr := overall_rating
    display_critical_level_cbr := critical_level
    display_break_source_cbr := break_source

else if not (cbrl_retest_active or cbrs_retest_active)
    // Clear buffers when not in RETEST phase
    display_distance_buffer_cbr := na
    display_time_buffer_cbr := na
    display_overall_rating_cbr := na
    display_critical_level_cbr := na
    display_break_source_cbr := ""

// ============================================
// UNIFIED PATTERN STATUS
// ============================================

var string active_pattern = "NONE"
var int pattern_quality = 0
var bool pattern_valid = false
var string quality_rating = ""

if epl_eps_valid
    active_pattern := epl_eps_pattern
    pattern_quality := epl_eps_quality
    pattern_valid := epl_eps_valid
else if cbrl_cbrs_valid
    active_pattern := cbrl_cbrs_pattern
    pattern_quality := cbrl_cbrs_quality
    pattern_valid := cbrl_cbrs_valid
else
    active_pattern := "NONE"
    pattern_quality := 0
    pattern_valid := false

if pattern_quality == 4
    quality_rating := "PERFECT"
else if pattern_quality == 3
    quality_rating := "GOOD"
else if pattern_quality == 2
    quality_rating := "MINIMUM"
else
    quality_rating := "INSUFFICIENT"

// ============================================
// PLOTTING - INDICATOR PANE WITH BACKGROUND
// ============================================

bgcolor_color = vol_regime == "EXPANSION" ? color.new(color.red, 50) : vol_regime == "ELEVATED" ? color.new(color.orange, 60) : vol_regime == "COMPRESSION" ? color.new(color.aqua, 50) : color.new(color.gray, 95)
bgcolor(bgcolor_color, title="Volatility Regime Background")

weighted_gap_color = adx_weighted_di_gap > 0 ? color.new(color.green, 0) : color.new(color.red, 0)
plot(adx_weighted_di_gap, color=weighted_gap_color, linewidth=2, title="ADX-Weighted DI Gap", style=plot.style_histogram)

hline(0, "Zero Line", color=color.new(color.gray, 70), linestyle=hline.style_solid)
hline(25, "Ref +25", color=color.new(color.green, 85), linestyle=hline.style_dotted, linewidth=1)
hline(20, "Ref +20", color=color.new(color.green, 90), linestyle=hline.style_dotted, linewidth=1)
hline(15, "Ref +15", color=color.new(color.green, 90), linestyle=hline.style_dotted, linewidth=1)
hline(10, "Ref +10", color=color.new(color.green, 90), linestyle=hline.style_dotted, linewidth=1)
hline(5, "Ref +5", color=color.new(color.green, 90), linestyle=hline.style_dotted, linewidth=1)
hline(-5, "Ref -5", color=color.new(color.red, 90), linestyle=hline.style_dotted, linewidth=1)
hline(-10, "Ref -10", color=color.new(color.red, 90), linestyle=hline.style_dotted, linewidth=1)
hline(-15, "Ref -15", color=color.new(color.red, 90), linestyle=hline.style_dotted, linewidth=1)
hline(-20, "Ref -20", color=color.new(color.red, 90), linestyle=hline.style_dotted, linewidth=1)
hline(-25, "Ref -25", color=color.new(color.red, 85), linestyle=hline.style_dotted, linewidth=1)

// ============================================
// EMA OVERLAYS ON PRICE CHART
// ============================================

plot(show_ema20 ? ema20 : na, color=color.new(color.blue, 0), linewidth=1, title="EMA 20", force_overlay=true)
ema50_plot = plot(show_ema50 ? ema50 : na, color=color.new(color.blue, 0), linewidth=2, title="EMA 50", force_overlay=true)
ema100_plot = plot(show_ema100 ? ema100 : na, color=color.new(color.purple, 0), linewidth=2, title="EMA 100", force_overlay=true)
plot(show_ema200 ? ema200 : na, color=color.new(color.white, 0), linewidth=2, title="EMA 200", force_overlay=true)

// ============================================
// EPL/EPS: 50-100 EMA ZONE HIGHLIGHTING
// ============================================

zone_fill_color = color(na)
if show_ema_zone_highlight and enable_epl_eps and epl_eps_pattern != "NONE" and epl_eps_valid
    if epl_eps_pattern == "EPL"
        zone_fill_color := color.new(color.green, 85)
    else if epl_eps_pattern == "EPS"
        zone_fill_color := color.new(color.red, 85)

fill(ema50_plot, ema100_plot, color=zone_fill_color, title="EPL/EPS Entry Zone")

// ============================================
// CBRL/CBRS: CONSOLIDATION BOX OVERLAYS
// ============================================

if show_consolidation_boxes and enable_cbrl_cbrs
    if in_consolidation and not na(current_consol_high) and not na(current_consol_low) and not na(consol_start_bar) and bar_index - consol_start_bar < 500
        box.new(consol_start_bar, current_consol_high, bar_index, current_consol_low, border_color=color.new(color.green, 0), bgcolor=color.new(color.green, 90), border_width=2, force_overlay=true)
    if array.size(consol_highs) > 0
        for i = 0 to array.size(consol_highs) - 1
            float box_high = array.get(consol_highs, i)
            float box_low = array.get(consol_lows, i)
            int box_start = array.get(consol_start_bars, i)
            int box_bars = array.get(consol_bar_counts, i)
            if bar_index - box_start < 500
                box.new(box_start, box_high, box_start + box_bars, box_low, border_color=color.new(color.gray, 50), bgcolor=color.new(color.gray, 95), border_width=1, force_overlay=true)

// CBRL/CBRS: Breakout Level Line
if enable_cbrl_cbrs and breakout_occurred and not na(breakout_level) and bar_index - breakout_bar < 500
    line.new(breakout_bar, breakout_level, bar_index, breakout_level, color=breakout_direction == 1 ? color.new(color.green, 30) : color.new(color.red, 30), width=2, style=line.style_dashed, force_overlay=true)

// ============================================
// BUFFER SYSTEM: CRITICAL LEVEL LINES
// ============================================

// EPL/EPS Critical Level Line (v1.1)
var line critical_level_line = na

if show_critical_line and enable_buffers and not na(display_critical_level) and epl_eps_valid and barstate.islast
    // Delete old line
    if not na(critical_level_line)
        line.delete(critical_level_line)
    
    // Draw new line extending 12 bars forward
    critical_level_line := line.new(bar_index, display_critical_level, bar_index + 12, display_critical_level, color=color.new(color.red, 0), width=2, style=line.style_dashed, extend=extend.none, force_overlay=true)
    
    // Add label
    label.new(bar_index, display_critical_level, "BREAK: " + str.tostring(display_critical_level, format.mintick), color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_left, size=size.small, force_overlay=true)

// CBRL/CBRS Critical Level Lines (v1.2 - RETEST phase only)
var line cbr_critical_line = na
var line cbr_breakout_line = na

if show_critical_line and enable_buffers and (cbrl_retest_active or cbrs_retest_active) and barstate.islast
    if not na(cbr_breakout_line)
        line.delete(cbr_breakout_line)
    if not na(cbr_critical_line)
        line.delete(cbr_critical_line)
    
    // Breakout level (green - entry reference)
    cbr_breakout_line := line.new(bar_index, breakout_level, bar_index + 12, breakout_level, color=color.new(color.green, 0), width=1, style=line.style_solid, extend=extend.none, force_overlay=true)
    label.new(bar_index, breakout_level, "ENTRY: " + str.tostring(breakout_level, format.mintick), color=color.new(color.green, 0), textcolor=color.white, style=label.style_label_left, size=size.small, force_overlay=true)
    
    // Failure level (red - invalidation)
    if not na(display_critical_level_cbr)
        cbr_critical_line := line.new(bar_index, display_critical_level_cbr, bar_index + 12, display_critical_level_cbr, color=color.new(color.red, 0), width=2, style=line.style_dashed, extend=extend.none, force_overlay=true)
        label.new(bar_index, display_critical_level_cbr, "BREAK: " + str.tostring(display_critical_level_cbr, format.mintick), color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_left, size=size.small, force_overlay=true)

// ============================================
// VOLATILITY WAVE CIRCLES ON PRICE CHART
// ============================================

var label wave_start_label = na
var label wave_peak_label = na

if wave_start_signal
    label.delete(wave_start_label)
    wave_start_label := label.new(bar_index, low, "●", color=color.new(color.green, 100), textcolor=color.new(color.green, 0), style=label.style_none, size=size.normal, yloc=yloc.belowbar, force_overlay=true)

if wave_peak_signal
    label.delete(wave_peak_label)
    wave_peak_label := label.new(bar_index, high, "●", color=color.new(color.red, 100), textcolor=color.new(color.red, 0), style=label.style_none, size=size.normal, yloc=yloc.abovebar, force_overlay=true)

// ============================================
// PATTERN LABELS ON PRICE CHART
// ============================================

var label pattern_label = na
if show_pattern_label and barstate.islast and active_pattern != "NONE" and pattern_valid
    label.delete(pattern_label)
    label_text = active_pattern + " " + str.tostring(pattern_quality) + "/4\n" + quality_rating
    label_color = pattern_quality == 4 ? color.new(color.green, 0) : pattern_quality == 3 ? color.new(color.green, 30) : color.new(color.yellow, 0)
    label_y = (active_pattern == "EPL" or active_pattern == "CBRL") ? low : high
    label_style = (active_pattern == "EPL" or active_pattern == "CBRL") ? label.style_label_up : label.style_label_down
    pattern_label := label.new(bar_index, label_y, label_text, color=label_color, textcolor=color.white, style=label_style, size=size.normal)

// ============================================
// KELTNER CHANNEL OVERLAYS ON PRICE CHART
// ============================================

keltner_upper_plot = plot(show_keltner ? keltner_upper : na, color=color.new(color.fuchsia, 0), linewidth=1, title="Keltner Upper", display=display.none, force_overlay=true)
keltner_lower_plot = plot(show_keltner ? keltner_lower : na, color=color.new(color.fuchsia, 0), linewidth=1, title="Keltner Lower", display=display.none, force_overlay=true)
fill(keltner_upper_plot, keltner_lower_plot, color=show_keltner ? color.new(color.fuchsia, 70) : na, title="Keltner Fill")
plot(show_keltner ? keltner_basis : na, color=color.new(color.fuchsia, 30), linewidth=1, title="Keltner Basis", style=plot.style_circles, force_overlay=true)

// ============================================
// TABLE - 8 ROWS (v1.2 WITH CBR BUFFERS)
// ============================================

table_pos = table_position == "top_left" ? position.top_left : table_position == "top_center" ? position.top_center : table_position == "top_right" ? position.top_right : table_position == "middle_left" ? position.middle_left : table_position == "middle_center" ? position.middle_center : table_position == "middle_right" ? position.middle_right : table_position == "bottom_left" ? position.bottom_left : table_position == "bottom_center" ? position.bottom_center : position.bottom_right

text_size_header = table_text_size == "auto" ? size.auto : table_text_size == "small" ? size.small : size.normal
text_size_cells = table_text_size == "auto" ? size.auto : table_text_size == "small" ? size.small : size.normal

var table macro_table = table.new(table_pos, 2, 9, border_width=2, force_overlay=true)

if barstate.islast
    table.cell(macro_table, 0, 0, "MACRO TREND", text_color=color.white, bgcolor=color.new(color.gray, 20), text_size=text_size_header)
    table.cell(macro_table, 1, 0, macro_trend, text_color=color.white, bgcolor=macro_trend == "BULL" ? color.new(color.green, 30) : color.new(color.red, 30), text_size=text_size_header)
    
    vol_regime_color = vol_regime == "EXPANSION" ? color.new(color.red, 30) : vol_regime == "ELEVATED" ? color.new(color.orange, 30) : vol_regime == "COMPRESSION" ? color.new(color.aqua, 30) : color.new(color.gray, 70)
    vol_regime_text = vol_regime + " (" + str.tostring(math.round(atr_ratio, 2)) + ")"
    table.cell(macro_table, 0, 1, "Vol Regime", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells)
    table.cell(macro_table, 1, 1, vol_regime_text, text_color=color.white, bgcolor=vol_regime_color, text_size=text_size_cells)
    
    wave_stage_color = wave_stage == "STARTING" ? color.new(color.green, 40) : wave_stage == "PEAKING" ? color.new(color.red, 40) : wave_stage == "ENDING" ? color.new(color.orange, 50) : color.new(color.gray, 70)
    wave_stage_text = na(wave_percentile_rank) ? "Warming up..." : wave_stage + " (" + str.tostring(math.round(wave_percentile_rank, 0)) + "%)"
    table.cell(macro_table, 0, 2, "Wave Stage", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells, tooltip="Volatility wave lifecycle:\nSTARTING: Rising from calm (green circle)\nPEAKING: Extreme high (>90%) (red circle)\nENDING: Cooling down\nDORMANT: Waiting for next wave\n\nDetection: " + wave_detection_method)
    table.cell(macro_table, 1, 2, wave_stage_text, text_color=color.white, bgcolor=wave_stage_color, text_size=text_size_cells)
    
    table.cell(macro_table, 0, 3, "ADX", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells)
    table.cell(macro_table, 1, 3, str.tostring(math.round(adx, 1)), text_color=color.white, bgcolor=color.new(color.blue, 50), text_size=text_size_cells)
    
    var string duration_text = ""
    var color duration_bgcolor = color.gray
    if duration_display_mode == "Basic + Labels"
        duration_text := str.tostring(trend_bars) + " bars (" + duration_class + ") | " + str.tostring(math.round(trend_consistency, 0)) + "% (" + consistency_class + ")"
        duration_bgcolor := color.new(color.gray, 70)
    else if duration_display_mode == "With Entry Quality"
        duration_text := str.tostring(trend_bars) + " bars (" + duration_class + ") | " + str.tostring(math.round(trend_consistency, 0)) + "% (" + consistency_class + ")\n" + entry_quality
        duration_bgcolor := color.new(color.gray, 70)
    else
        duration_text := str.tostring(trend_bars) + " bars | " + str.tostring(math.round(trend_consistency, 0)) + "% confirm"
        duration_bgcolor := entry_quality_color
    table.cell(macro_table, 0, 4, "Trend Duration", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells, tooltip="Duration: FRESH (<10) | DEVELOPING (10-50) | MATURE (50-100) | EXTENDED (100+)\nConsistency: STRONG (80%+) | MODERATE (60-80%) | WEAK (50-60%) | VERY WEAK (<50%)\nConsistency measures % of bars CONFIRMING current trend\nEntry Quality: GREEN = Prime | YELLOW = Marginal | RED = Avoid")
    table.cell(macro_table, 1, 4, duration_text, text_color=color.white, bgcolor=duration_bgcolor, text_size=text_size_cells)
    
    var string keltner_text = ""
    var color keltner_color = color.gray
    keltner_text := str.tostring(math.round(keltner_position, 0)) + "% | " + keltner_zone + (is_extreme ? " (extreme)" : "")
    if is_extreme or keltner_position >= 95 or keltner_position <= 5
        keltner_color := color.new(color.red, 30)
    else if keltner_position >= 80 or keltner_position <= 20
        keltner_color := color.new(color.orange, 50)
    else
        keltner_color := color.new(color.gray, 70)
    table.cell(macro_table, 0, 5, "Keltner Pos", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells, tooltip="Position within Keltner Channel:\nUPPER (80-100%): Extended high\nMID-HIGH (60-80%): Above average\nMIDDLE (40-60%): Neutral\nMID-LOW (20-40%): Below average\nLOWER (0-20%): Compressed low\n(extreme) = Beyond bands")
    table.cell(macro_table, 1, 5, keltner_text, text_color=color.white, bgcolor=keltner_color, text_size=text_size_cells)
    
    var string pattern_text = ""
    var color pattern_color = color.gray
    var string pattern_tooltip = ""
    if active_pattern == "EPL" or active_pattern == "EPS"
        if pattern_valid
            pattern_text := active_pattern + " SETUP | " + str.tostring(pattern_quality) + "/4 " + quality_rating
            pattern_color := pattern_quality == 4 ? color.new(color.green, 20) : pattern_quality == 3 ? color.new(color.green, 40) : color.new(color.yellow, 40)
        else
            pattern_text := active_pattern + " (" + str.tostring(pattern_quality) + "/4) - SKIP"
            pattern_color := color.new(color.red, 40)
        pattern_tooltip := "EPL/EPS Pattern Detection:\nCore Requirements (ALL must be met):\n- Macro Trend aligned (BULL for EPL, BEAR for EPS)\n- Price in 50-100 EMA zone\n- No 100 EMA violation during pullback\n- Keltner >50% (EPL) or <50% (EPS)\n\nQuality Score (min 2/4):\n+1 Wave Stage = STARTING/NORMAL\n+1 Vol Regime = NORMAL/COMPRESSION\n+1 ADX 15-40\n+1 Trend Duration <80 bars\n\n4/4 = PERFECT | 3/4 = GOOD | 2/4 = MINIMUM | <2 = SKIP"
    else if active_pattern == "CBRL" or active_pattern == "CBRS"
        if pattern_valid
            pattern_text := active_pattern + " SETUP | " + str.tostring(pattern_quality) + "/4 " + quality_rating + "\n" + pattern_state
            pattern_color := pattern_quality == 4 ? color.new(color.green, 20) : pattern_quality == 3 ? color.new(color.green, 40) : color.new(color.yellow, 40)
        else if pattern_state == "CONSOLIDATING" or pattern_state == "BREAKOUT" or pattern_state == "RETEST"
            pattern_text := pattern_state + " | " + str.tostring(consol_bars) + " bars"
            pattern_color := color.new(color.blue, 50)
        else
            pattern_text := active_pattern + " (" + str.tostring(pattern_quality) + "/4) - SKIP"
            pattern_color := color.new(color.red, 40)
        pattern_tooltip := "CBRL/CBRS Pattern Detection:\nCore Requirements (ALL must be met):\n- Macro Trend aligned (BULL for CBRL, BEAR for CBRS)\n- ADX > 20\n- Consolidation 10-30 bars (1.5-4.0 ATR height)\n- Breakout confirmed\n- Retest within 3-5 bars\n\nQuality Score (min 2/4):\n+1 Wave Stage = NORMAL/STARTING\n+1 Vol Regime = NORMAL/COMPRESSION\n+1 Keltner >50% (CBRL) or <50% (CBRS)\n+1 Consolidation near 50-100 EMA\n\n4/4 = PERFECT | 3/4 = GOOD | 2/4 = MINIMUM | <2 = SKIP"
    else
        if pattern_state == "CONSOLIDATING"
            pattern_text := "CONSOLIDATING | " + str.tostring(consol_bars) + " bars"
            pattern_color := color.new(color.blue, 50)
        else if pattern_state == "BREAKOUT"
            pattern_text := "BREAKOUT | " + str.tostring(bars_since_breakout) + " bars since"
            pattern_color := color.new(color.orange, 50)
        else
            pattern_text := "SCANNING"
            pattern_color := color.new(color.gray, 70)
        pattern_tooltip := "Unified Pattern Detection:\n- EPL: EMA Pullback Long\n- EPS: EMA Pullback Short\n- CBRL: Consolidation Breakout Retest Long\n- CBRS: Consolidation Breakout Retest Short\n\nAll patterns require 2/4 minimum quality score"
    table.cell(macro_table, 0, 6, "Pattern", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells, tooltip=pattern_tooltip)
    table.cell(macro_table, 1, 6, pattern_text, text_color=color.white, bgcolor=pattern_color, text_size=text_size_cells)
    
    // === ROW 7: BUFFER DISPLAY (v1.2 - EPL/EPS + CBRL/CBRS) ===
    if enable_buffers
        // Show EPL/EPS buffers if pattern active
        if not na(display_distance_buffer) and not na(display_time_buffer) and epl_eps_valid
            buffer_text = "BUFFER: " + str.tostring(display_distance_buffer, "#.#") + " ATR / " + str.tostring(display_time_buffer, "#.0") + " bars"
            buffer_emoji = display_overall_rating == "STRONG" ? "🟢" : display_overall_rating == "MODERATE" ? "🟡" : display_overall_rating == "WEAK" ? "🟠" : "🔴"
            buffer_full_text = buffer_text + " " + buffer_emoji + " " + display_overall_rating
            buffer_color = display_overall_rating == "STRONG" ? color.new(color.green, 80) : display_overall_rating == "MODERATE" ? color.new(color.yellow, 80) : display_overall_rating == "WEAK" ? color.new(color.orange, 80) : color.new(color.red, 80)
            buffer_tooltip = "Pattern Stability Buffers (v1.1):\n\nDistance Buffer: " + str.tostring(display_distance_buffer, "#.#") + " ATR to invalidation\nTime Buffer: " + str.tostring(display_time_buffer, "#.0") + " bars until ADX threshold\nOverall Risk: " + display_overall_rating
            table.cell(macro_table, 0, 7, "Risk Buffer", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells, tooltip=buffer_tooltip)
            table.cell(macro_table, 1, 7, buffer_full_text, text_color=color.white, bgcolor=buffer_color, text_size=text_size_cells)
        
        // Show CBRL/CBRS buffers if in RETEST phase
        else if not na(display_distance_buffer_cbr) and not na(display_time_buffer_cbr) and (cbrl_retest_active or cbrs_retest_active)
            buffer_text = "BUFFER: " + str.tostring(display_distance_buffer_cbr, "#.#") + " ATR / " + str.tostring(display_time_buffer_cbr, "#.0") + " bars"
            buffer_emoji = display_overall_rating_cbr == "STRONG" ? "🟢" : display_overall_rating_cbr == "MODERATE" ? "🟡" : display_overall_rating_cbr == "WEAK" ? "🟠" : "🔴"
            buffer_full_text = buffer_text + " " + buffer_emoji + " " + display_overall_rating_cbr
            buffer_color = display_overall_rating_cbr == "STRONG" ? color.new(color.green, 80) : display_overall_rating_cbr == "MODERATE" ? color.new(color.yellow, 80) : display_overall_rating_cbr == "WEAK" ? color.new(color.orange, 80) : color.new(color.red, 80)
            buffer_tooltip = "Invalidation Buffers (v1.2 - RETEST Phase):\n\nDistance Buffer: " + str.tostring(display_distance_buffer_cbr, "#.#") + " ATR to failure\nTime Buffer: " + str.tostring(display_time_buffer_cbr, "#.0") + " bars until window expires\nOverall Risk: " + display_overall_rating_cbr
            table.cell(macro_table, 0, 7, "Risk Buffer", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells, tooltip=buffer_tooltip)
            table.cell(macro_table, 1, 7, buffer_full_text, text_color=color.white, bgcolor=buffer_color, text_size=text_size_cells)
        
        // Show phase-appropriate messages for CBRL/CBRS
        else if pattern_state == "CONSOLIDATING"
            table.cell(macro_table, 0, 7, "Phase Status", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells)
            table.cell(macro_table, 1, 7, "Waiting for breakout...", text_color=color.white, bgcolor=color.new(color.blue, 80), text_size=text_size_cells)
        
        else if pattern_state == "BREAKOUT"
            breakout_text = "Breakout at: " + str.tostring(breakout_level, format.mintick)
            table.cell(macro_table, 0, 7, "Phase Status", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells)
            table.cell(macro_table, 1, 7, breakout_text, text_color=color.white, bgcolor=color.new(color.orange, 80), text_size=text_size_cells)
        
        else
            table.cell(macro_table, 0, 7, "Risk Buffer", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells)
            table.cell(macro_table, 1, 7, "---", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=text_size_cells)
    
    // === ROW 8: CRITICAL LEVEL (v1.2 - EPL/EPS + CBRL/CBRS) ===
    if show_critical_level and enable_buffers
        // Show EPL/EPS critical level
        if not na(display_critical_level) and epl_eps_valid
            watch_text = "WATCH: " + str.tostring(display_critical_level, format.mintick) + "\n(" + display_break_source + ")"
            watch_tooltip = "Critical Price Level:\n\nPattern invalidates if price reaches:\n" + str.tostring(display_critical_level, format.mintick)
            table.cell(macro_table, 0, 8, "Critical Level", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells, tooltip=watch_tooltip)
            table.cell(macro_table, 1, 8, watch_text, text_color=color.white, bgcolor=color.new(color.red, 90), text_size=text_size_cells)
        
        // Show CBRL/CBRS critical level during RETEST
        else if not na(display_critical_level_cbr) and (cbrl_retest_active or cbrs_retest_active)
            watch_text = "WATCH: " + str.tostring(display_critical_level_cbr, format.mintick) + "\n(" + display_break_source_cbr + ")"
            watch_tooltip = "Critical Price Level (RETEST):\n\nRetest fails if price reaches:\n" + str.tostring(display_critical_level_cbr, format.mintick)
            table.cell(macro_table, 0, 8, "Critical Level", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells, tooltip=watch_tooltip)
            table.cell(macro_table, 1, 8, watch_text, text_color=color.white, bgcolor=color.new(color.red, 90), text_size=text_size_cells)
        
        else
            table.cell(macro_table, 0, 8, "Critical Level", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=text_size_cells)
            table.cell(macro_table, 1, 8, "---", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=text_size_cells)